### Понимание Кучи (Heap) и Стека (Stack)

#### Куча (Heap)

Куча - это область памяти, где хранятся динамически выделяемые данные. В этой области располагаются объекты и другие сложные структуры данных. Важно отметить следующие особенности кучи:

- **Динамическое выделение**: Память в куче выделяется во время выполнения программы при необходимости создания объектов.
- **Произвольный доступ**: Данные в куче могут быть доступны в произвольном порядке, и к ним можно обращаться через ссылки.
- **Управление памятью**: В языках программирования с автоматическим управлением памятью, таких как JavaScript, сборщик мусора автоматически освобождает память, когда объекты больше не используются.

#### Стек (Stack)

Стек - это область памяти, используемая для хранения локальных переменных и вызовов функций. В стеке данные организуются в виде структуры данных Last-In-First-Out (LIFO), что означает, что последний элемент, помещенный в стек, будет первым, вынутым из него. Важные характеристики стека включают:

- **Локальные переменные**: Каждая функция при ее вызове создает новую область памяти в стеке для своих локальных переменных и параметров.
- **Управление вызовами функций**: Каждый раз, когда функция вызывается, информация о ней помещается в стек, а при завершении выполнения функции, эта информация удаляется из стека.
- **Эффективное управление памятью**: Так как данные в стеке организованы по принципу LIFO, управление памятью в стеке более эффективно и менее затратно, чем в куче.

#### Ключевые моменты

- Куча используется для хранения динамически выделяемых данных, таких как объекты, в то время как стек используется для управления вызовами функций и хранения локальных переменных.
- Данные в куче доступны через ссылки и могут иметь произвольный доступ, в то время как данные в стеке организованы в определенном порядке в соответствии с вызовами функций.
- Правильное использование и понимание характеристик кучи и стека помогает разработчикам оптимизировать производительность и управление памятью в своих программах.

В **JavaScript** различают примитивные типы данных и ссылочные типы. Примитивные типы хранятся в стеке и передаются по значению, в то время как ссылочные типы хранятся в куче и передаются по ссылке. Вот пример кода, который демонстрирует эти различия:

```javascript
// Примитивные типы
let a = 10; // Число - примитивный тип
let b = a; // b получает копию значения a
b = 20; // Изменение b не влияет на a
console.log(a); // Выведет 10
console.log(b); // Выведет 20

// Ссылочные типы
let obj1 = { name: "Alice" }; // obj1 ссылается на объект в куче
let obj2 = obj1; // obj2 копирует ссылку на тот же объект, что и obj1
obj2.name = "Bob"; // Изменение obj2.name также изменяет obj1.name, так как они ссылаются на один и тот же объект
console.log(obj1.name); // Выведет "Bob"
console.log(obj2.name); // Выведет "Bob"

// Пример с функцией и примитивным типом
function changePrimitive(value) {
    value = 100; // Это изменение не повлияет на переменную за пределами функции
}

let c = 50;
changePrimitive(c);
console.log(c); // Выведет 50, так как примитивы передаются по значению

// Пример с функцией и ссылочным типом
function changeObject(obj) {
    obj.name = "Charlie"; // Изменения внутри функции влияют на исходный объект
}

let obj3 = { name: "Dave" };
changeObject(obj3);
console.log(obj3.name); // Выведет "Charlie", так как ссылочные типы передаются по ссылке
```

В этом коде:
- Примитивные типы (`a`, `b`, `c`) демонстрируют, что они хранятся и передаются по значению. Изменение одной переменной не влияет на другую, даже если одна была инициализирована как копия другой.
- Ссылочные типы (`obj1`, `obj2`, `obj3`) показывают, что они хранятся в куче и передаются по ссылке. Когда одна переменная копирует ссылку другой, обе переменные в итоге ссылаются на один и тот же объект в памяти. Изменение объекта через одну ссылку отражается на всех ссылках, указывающих на этот объект.
- Функции `changePrimitive` и `changeObject` иллюстрируют, как изменения внутри функции могут влиять на внешние переменные в зависимости от того, является ли переданный аргумент примитивным или ссылочным типом.

```javascript
function f(){
    const obj = {
        name:"Name"
    }

    console.log(obj,'inside')
}
f()
    console.log(obj,'outside')

```

В приведённом примере кода переменная obj объявлена внутри функции f с использованием ключевого слова **const**, что делает её локальной переменной для этой функции. Это значит, что obj существует и доступна только внутри области видимости функции f. Поэтому, когда вы пытаетесь обратиться к obj снаружи функции (во втором console.log), вы получаете ошибку, потому что в этой области видимости переменная obj не определена.

Ключевое  заключается в путанице между областью видимости переменных и местом их хранения (куча или стек). Независимо от того, где хранится значение переменной (в куче или в стеке), область видимости переменной определяется местом её объявления в коде. В данном случае, даже если объект, на который ссылается переменная obj, может быть размещён в куче, сама переменная obj имеет локальную область видимости внутри функции f и не доступна за её пределами.